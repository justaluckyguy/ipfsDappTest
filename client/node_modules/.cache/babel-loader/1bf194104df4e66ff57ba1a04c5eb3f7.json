{"ast":null,"code":"'use strict';\n\nconst mh = require('multihashes');\nconst multibase = require('multibase');\nconst multicodec = require('multicodec');\nconst codecs = require('multicodec/src/base-table');\nconst CIDUtil = require('./cid-util');\nconst withIs = require('class-is');\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n *\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   *\n   * ..if only JS had traits..\n   * ```\n   *\n   * @param {string|Buffer} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   *\n   * @example\n   *\n   * new CID(<version>, <codec>, <multihash>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   *\n   */\n  constructor(version, codec, multihash) {\n    if (module.exports.isCID(version)) {\n      let cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = Buffer.from(cid.multihash);\n      return;\n    }\n    if (typeof version === 'string') {\n      if (multibase.isEncoded(version)) {\n        // CID String (encoded with multibase)\n        const cid = multibase.decode(version);\n        version = parseInt(cid.slice(0, 1).toString('hex'), 16);\n        codec = multicodec.getCodec(cid.slice(1));\n        multihash = multicodec.rmPrefix(cid.slice(1));\n      } else {\n        // bs58 string encoded multihash\n        codec = 'dag-pb';\n        multihash = mh.fromB58String(version);\n        version = 0;\n      }\n    } else if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1);\n      const v = parseInt(firstByte.toString('hex'), 16);\n      if (v === 0 || v === 1) {\n        // CID\n        const cid = version;\n        version = v;\n        codec = multicodec.getCodec(cid.slice(1));\n        multihash = multicodec.rmPrefix(cid.slice(1));\n      } else {\n        // multihash\n        codec = 'dag-pb';\n        multihash = version;\n        version = 0;\n      }\n    }\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec;\n\n    /**\n     * @type {number}\n     */\n    this.version = version;\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash;\n    CID.validateCID(this);\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get buffer() {\n    let buffer = this._buffer;\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash;\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([Buffer.from('01', 'hex'), multicodec.getCodeVarint(this.codec), this.multihash]);\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', {\n        value: buffer\n      });\n    }\n    return buffer;\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n  get prefix() {\n    return Buffer.concat([Buffer.from(`0${this.version}`, 'hex'), multicodec.getCodeVarint(this.codec), mh.prefix(this.multihash)]);\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0() {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n    }\n    const {\n      name,\n      length\n    } = mh.decode(this.multihash);\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n    }\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n    }\n    return new _CID(0, this.codec, this.multihash);\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1() {\n    return new _CID(1, this.codec, this.multihash);\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base='base58btc'] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString(base) {\n    base = base || 'base58btc';\n    switch (this.version) {\n      case 0:\n        {\n          if (base !== 'base58btc') {\n            throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n          }\n          return mh.toB58String(this.multihash);\n        }\n      case 1:\n        return multibase.encode(base, this.buffer).toString();\n      default:\n        throw new Error('Unsupported version');\n    }\n  }\n  toString(base) {\n    return this.toBaseEncodedString(base);\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON() {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    };\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals(other) {\n    return this.codec === other.codec && this.version === other.version && this.multihash.equals(other.multihash);\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID(other) {\n    let errorMsg = CIDUtil.checkCIDComponents(other);\n    if (errorMsg) {\n      throw new Error(errorMsg);\n    }\n  }\n}\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"names":["mh","require","multibase","multicodec","codecs","CIDUtil","withIs","CID","constructor","version","codec","multihash","module","exports","isCID","cid","Buffer","from","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","isBuffer","firstByte","v","validateCID","buffer","_buffer","concat","getCodeVarint","Error","Object","defineProperty","value","prefix","toV0","name","length","_CID","toV1","toBaseEncodedString","base","toB58String","encode","toJSON","hash","equals","other","errorMsg","checkCIDComponents","className","symbolName"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/is-ipfs/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\n\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst codecs = require('multicodec/src/base-table')\nconst CIDUtil = require('./cid-util')\nconst withIs = require('class-is')\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Buffer} multihash\n *\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Buffer)\n   *   if (0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   *\n   * ..if only JS had traits..\n   * ```\n   *\n   * @param {string|Buffer} version\n   * @param {string} [codec]\n   * @param {Buffer} [multihash]\n   *\n   * @example\n   *\n   * new CID(<version>, <codec>, <multihash>)\n   * new CID(<cidStr>)\n   * new CID(<cid.buffer>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   *\n   */\n  constructor (version, codec, multihash) {\n    if (module.exports.isCID(version)) {\n      let cid = version\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = Buffer.from(cid.multihash)\n      return\n    }\n    if (typeof version === 'string') {\n      if (multibase.isEncoded(version)) { // CID String (encoded with multibase)\n        const cid = multibase.decode(version)\n        version = parseInt(cid.slice(0, 1).toString('hex'), 16)\n        codec = multicodec.getCodec(cid.slice(1))\n        multihash = multicodec.rmPrefix(cid.slice(1))\n      } else { // bs58 string encoded multihash\n        codec = 'dag-pb'\n        multihash = mh.fromB58String(version)\n        version = 0\n      }\n    } else if (Buffer.isBuffer(version)) {\n      const firstByte = version.slice(0, 1)\n      const v = parseInt(firstByte.toString('hex'), 16)\n      if (v === 0 || v === 1) { // CID\n        const cid = version\n        version = v\n        codec = multicodec.getCodec(cid.slice(1))\n        multihash = multicodec.rmPrefix(cid.slice(1))\n      } else { // multihash\n        codec = 'dag-pb'\n        multihash = version\n        version = 0\n      }\n    }\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec\n\n    /**\n     * @type {number}\n     */\n    this.version = version\n\n    /**\n     * @type {Buffer}\n     */\n    this.multihash = multihash\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Buffer`\n   *\n   * @return {Buffer}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get buffer () {\n    let buffer = this._buffer\n\n    if (!buffer) {\n      if (this.version === 0) {\n        buffer = this.multihash\n      } else if (this.version === 1) {\n        buffer = Buffer.concat([\n          Buffer.from('01', 'hex'),\n          multicodec.getCodeVarint(this.codec),\n          this.multihash\n        ])\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this buffer so it doesn't have to be recreated\n      Object.defineProperty(this, '_buffer', { value: buffer })\n    }\n\n    return buffer\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Buffer}\n   * @readonly\n   */\n  get prefix () {\n    return Buffer.concat([\n      Buffer.from(`0${this.version}`, 'hex'),\n      multicodec.getCodeVarint(this.codec),\n      mh.prefix(this.multihash)\n    ])\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new _CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new _CID(1, this.codec, this.multihash)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base='base58btc'] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base) {\n    base = base || 'base58btc'\n\n    switch (this.version) {\n      case 0: {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n        }\n        return mh.toB58String(this.multihash)\n      }\n      case 1:\n        return multibase.encode(base, this.buffer).toString()\n      default:\n        throw new Error('Unsupported version')\n    }\n  }\n\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      this.multihash.equals(other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID (other) {\n    let errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n})\n\n_CID.codecs = codecs\n\nmodule.exports = _CID\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}