{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict';\n\nconst mh = require('multihashes');\nconst crypto = require('libp2p-crypto');\nconst assert = require('assert');\nconst waterfall = require('async/waterfall');\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n  get id() {\n    return this._id;\n  }\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n  get privKey() {\n    return this._privKey;\n  }\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n  }\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey() {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey);\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey() {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey);\n    }\n  }\n\n  // pretty print\n  toPrint() {\n    return this.toJSON();\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  }\n\n  // encode/decode functions\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n  toBytes() {\n    return this.id;\n  }\n  toB58String() {\n    return this._idB58String;\n  }\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n}\nexports = module.exports = PeerId;\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  waterfall([cb => crypto.keys.generateKeyPair('RSA', opts.bits, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new PeerId(digest, privKey));\n  });\n};\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str));\n};\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf);\n};\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str));\n};\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let pubKey;\n  try {\n    let buf = key;\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = crypto.keys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new PeerId(digest, null, pubKey));\n  });\n};\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let buf = key;\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n  waterfall([cb => crypto.keys.unmarshalPrivateKey(buf, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, new PeerId(digest, privKey, privKey.public));\n  });\n};\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n  if (rawPrivKey) {\n    waterfall([cb => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => priv.public.hash((err, digest) => {\n      cb(err, digest, priv);\n    }), (privDigest, priv, cb) => {\n      if (pub) {\n        pub.hash((err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest);\n        });\n      } else {\n        cb(null, privDigest, priv);\n      }\n    }], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err);\n      }\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'));\n      }\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'));\n      }\n      callback(null, new PeerId(id, priv, pub));\n    });\n  } else {\n    callback(null, new PeerId(id, null, pub));\n  }\n};\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"names":["mh","require","crypto","assert","waterfall","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","marshalPubKey","keys","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","exports","module","create","opts","bits","cb","generateKeyPair","hash","err","digest","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","unmarshalPublicKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/peer-info/node_modules/peer-id/src/index.js"],"sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst crypto = require('libp2p-crypto')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // pretty print\n  toPrint () {\n    return this.toJSON()\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nexports = module.exports = PeerId\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n\n  waterfall([\n    (cb) => crypto.keys.generateKeyPair('RSA', opts.bits, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey))\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = crypto.keys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, null, pubKey))\n  })\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  waterfall([\n    (cb) => crypto.keys.unmarshalPrivateKey(buf, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public))\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (rawPrivKey) {\n    waterfall([\n      (cb) => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb),\n      (priv, cb) => priv.public.hash((err, digest) => {\n        cb(err, digest, priv)\n      }),\n      (privDigest, priv, cb) => {\n        if (pub) {\n          pub.hash((err, pubDigest) => {\n            cb(err, privDigest, priv, pubDigest)\n          })\n        } else {\n          cb(null, privDigest, priv)\n        }\n      }\n    ], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'))\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'))\n      }\n\n      callback(null, new PeerId(id, priv, pub))\n    })\n  } else {\n    callback(null, new PeerId(id, null, pub))\n  }\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}