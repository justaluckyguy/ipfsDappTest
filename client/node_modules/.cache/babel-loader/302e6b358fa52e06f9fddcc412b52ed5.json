{"ast":null,"code":"const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput(input) {\n  let ret;\n  if (input instanceof Uint8Array) {\n    ret = input;\n  } else if (typeof input === 'string') {\n    const encoder = new TextEncoder();\n    ret = encoder.encode(input);\n  } else {\n    throw new Error(ERROR_MSG_INPUT);\n  }\n  return ret;\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex(bytes) {\n  return Array.prototype.map.call(bytes, function (n) {\n    return (n < 16 ? '0' : '') + n.toString(16);\n  }).join('');\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex(val) {\n  return (0x100000000 + val).toString(16).substring(1);\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint(label, arr, size) {\n  let msg = '\\n' + label + ' = ';\n  for (let i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase();\n      msg += ' ';\n      msg += uint32ToHex(arr[i + 1]).toUpperCase();\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase();\n      msg += uint32ToHex(arr[i]).toUpperCase();\n    } else throw new Error('Invalid size ' + size);\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ');\n    } else if (i < arr.length - 2) {\n      msg += ' ';\n    }\n  }\n  console.log(msg);\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed(hashFn, N, M) {\n  let startMs = new Date().getTime();\n  const input = new Uint8Array(N);\n  for (let i = 0; i < N; i++) {\n    input[i] = i % 256;\n  }\n  const genMs = new Date().getTime();\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms');\n  startMs = genMs;\n  for (let i = 0; i < M; i++) {\n    const hashHex = hashFn(input);\n    const hashMs = new Date().getTime();\n    const ms = hashMs - startMs;\n    startMs = hashMs;\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');\n    console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND');\n  }\n}\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n};","map":{"version":3,"names":["ERROR_MSG_INPUT","normalizeInput","input","ret","Uint8Array","encoder","TextEncoder","encode","Error","toHex","bytes","Array","prototype","map","call","n","toString","join","uint32ToHex","val","substring","debugPrint","label","arr","size","msg","i","length","toUpperCase","console","log","testSpeed","hashFn","N","M","startMs","Date","getTime","genMs","hashHex","hashMs","ms","Math","round","module","exports"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/blakejs/util.js"],"sourcesContent":["const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput (input) {\n  let ret\n  if (input instanceof Uint8Array) {\n    ret = input\n  } else if (typeof input === 'string') {\n    const encoder = new TextEncoder()\n    ret = encoder.encode(input)\n  } else {\n    throw new Error(ERROR_MSG_INPUT)\n  }\n  return ret\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex (bytes) {\n  return Array.prototype.map\n    .call(bytes, function (n) {\n      return (n < 16 ? '0' : '') + n.toString(16)\n    })\n    .join('')\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex (val) {\n  return (0x100000000 + val).toString(16).substring(1)\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint (label, arr, size) {\n  let msg = '\\n' + label + ' = '\n  for (let i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase()\n      msg += ' '\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n      msg += uint32ToHex(arr[i]).toUpperCase()\n    } else throw new Error('Invalid size ' + size)\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ')\n    } else if (i < arr.length - 2) {\n      msg += ' '\n    }\n  }\n  console.log(msg)\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed (hashFn, N, M) {\n  let startMs = new Date().getTime()\n\n  const input = new Uint8Array(N)\n  for (let i = 0; i < N; i++) {\n    input[i] = i % 256\n  }\n  const genMs = new Date().getTime()\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms')\n  startMs = genMs\n\n  for (let i = 0; i < M; i++) {\n    const hashHex = hashFn(input)\n    const hashMs = new Date().getTime()\n    const ms = hashMs - startMs\n    startMs = hashMs\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')\n    console.log(\n      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'\n    )\n  }\n}\n\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}