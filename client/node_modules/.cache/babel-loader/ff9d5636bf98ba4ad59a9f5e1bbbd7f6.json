{"ast":null,"code":"'use strict';\n\nconst waterfall = require('async/waterfall');\nconst CID = require('cids');\nconst util = require('./util');\nexports = module.exports;\nexports.multicodec = 'dag-pb';\nexports.defaultHashAlg = 'sha2-256';\n\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([cb => util.deserialize(binaryBlob, cb), (node, cb) => {\n    // Return the deserialized block if no path is given\n    if (!path) {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n    const split = path.split('/');\n    if (split[0] === 'Links') {\n      let remainderPath = '';\n\n      // all links\n      if (!split[1]) {\n        return cb(null, {\n          value: node.links.map(l => l.toJSON()),\n          remainderPath: ''\n        });\n      }\n\n      // select one link\n\n      const values = {};\n\n      // populate both index number and name to enable both cases\n      // for the resolver\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[i] = values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      let value = values[split[1]];\n\n      // if remainderPath exists, value needs to be CID\n      if (split[2] === 'Hash') {\n        value = {\n          '/': value.hash\n        };\n      } else if (split[2] === 'Tsize') {\n        value = value.size;\n      } else if (split[2] === 'Name') {\n        value = value.name;\n      }\n      remainderPath = split.slice(3).join('/');\n      cb(null, {\n        value: value,\n        remainderPath: remainderPath\n      });\n    } else if (split[0] === 'Data') {\n      cb(null, {\n        value: node.data,\n        remainderPath: ''\n      });\n    } else {\n      // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n      // to a named link from the Links array. This is because go-ipfs and\n      // js-ipfs have historically supported the ability to do\n      // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n      const values = {};\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      const value = values[split[0]];\n      if (value) {\n        return cb(null, {\n          value: {\n            '/': value.hash\n          },\n          remainderPath: split.slice(1).join('/')\n        });\n      }\n      cb(new Error('path not available'));\n    }\n  }], callback);\n};\n\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    }\n    const paths = [];\n    paths.push('Links');\n    node.links.forEach((link, i) => {\n      paths.push(`Links/${i}/Name`);\n      paths.push(`Links/${i}/Tsize`);\n      paths.push(`Links/${i}/Hash`);\n    });\n    paths.push('Data');\n    callback(null, paths);\n  });\n};\n\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid;\n      try {\n        valid = CID.isCID(new CID(result.value['/']));\n      } catch (err) {\n        valid = false;\n      }\n      if (valid) {\n        return callback(null, result.value);\n      }\n    }\n    callback(null, false);\n  });\n};","map":{"version":3,"names":["waterfall","require","CID","util","exports","module","multicodec","defaultHashAlg","resolve","binaryBlob","path","callback","cb","deserialize","node","value","remainderPath","split","links","map","l","toJSON","values","forEach","i","link","name","hash","multihash","size","slice","join","data","Error","tree","options","err","paths","push","isLink","result","length","valid","isCID"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipld-dag-pb/src/resolver.js"],"sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\nconst CID = require('cids')\n\nconst util = require('./util')\n\nexports = module.exports\nexports.multicodec = 'dag-pb'\nexports.defaultHashAlg = 'sha2-256'\n\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([\n    (cb) => util.deserialize(binaryBlob, cb),\n    (node, cb) => {\n      // Return the deserialized block if no path is given\n      if (!path) {\n        return callback(null, {\n          value: node,\n          remainderPath: ''\n        })\n      }\n\n      const split = path.split('/')\n\n      if (split[0] === 'Links') {\n        let remainderPath = ''\n\n        // all links\n        if (!split[1]) {\n          return cb(null, {\n            value: node.links.map((l) => l.toJSON()),\n            remainderPath: ''\n          })\n        }\n\n        // select one link\n\n        const values = {}\n\n        // populate both index number and name to enable both cases\n        // for the resolver\n        node.links.forEach((l, i) => {\n          const link = l.toJSON()\n          values[i] = values[link.name] = {\n            hash: link.multihash,\n            name: link.name,\n            size: link.size\n          }\n        })\n\n        let value = values[split[1]]\n\n        // if remainderPath exists, value needs to be CID\n        if (split[2] === 'Hash') {\n          value = { '/': value.hash }\n        } else if (split[2] === 'Tsize') {\n          value = value.size\n        } else if (split[2] === 'Name') {\n          value = value.name\n        }\n\n        remainderPath = split.slice(3).join('/')\n\n        cb(null, { value: value, remainderPath: remainderPath })\n      } else if (split[0] === 'Data') {\n        cb(null, { value: node.data, remainderPath: '' })\n      } else {\n        // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n        // to a named link from the Links array. This is because go-ipfs and\n        // js-ipfs have historically supported the ability to do\n        // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n        const values = {}\n\n        node.links.forEach((l, i) => {\n          const link = l.toJSON()\n          values[link.name] = {\n            hash: link.multihash,\n            name: link.name,\n            size: link.size\n          }\n        })\n\n        const value = values[split[0]]\n\n        if (value) {\n          return cb(null, {\n            value: { '/': value.hash },\n            remainderPath: split.slice(1).join('/')\n          })\n        }\n\n        cb(new Error('path not available'))\n      }\n    }\n  ], callback)\n}\n\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  options = options || {}\n\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err)\n    }\n\n    const paths = []\n\n    paths.push('Links')\n\n    node.links.forEach((link, i) => {\n      paths.push(`Links/${i}/Name`)\n      paths.push(`Links/${i}/Tsize`)\n      paths.push(`Links/${i}/Hash`)\n    })\n\n    paths.push('Data')\n\n    callback(null, paths)\n  })\n}\n\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'))\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid\n      try {\n        valid = CID.isCID(new CID(result.value['/']))\n      } catch (err) {\n        valid = false\n      }\n      if (valid) {\n        return callback(null, result.value)\n      }\n    }\n\n    callback(null, false)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}