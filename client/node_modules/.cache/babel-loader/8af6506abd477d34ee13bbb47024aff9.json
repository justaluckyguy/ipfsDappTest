{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\nconst eachSeries = require('async/eachSeries');\nconst isStream = require('is-stream');\nconst once = require('once');\nconst prepareFile = require('./prepare-file');\nconst Multipart = require('./multipart');\nfunction headers(file) {\n  const name = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `file; filename=\"${name}\"`\n  };\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n  return header;\n}\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n    retStream._read = n => {};\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n      try {\n        const files = prepareFile(file, options).map(file => Object.assign({\n          headers: headers(file)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n          if (err) {\n            return next(err);\n          }\n          if (ended) {\n            multipart.end();\n          }\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n      response.on('error', err => retStream.emit('error', err));\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    });\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","name","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipfs-api/src/utils/send-files-stream.js"],"sourcesContent":["'use strict'\n\nconst Duplex = require('stream').Duplex\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file) {\n  const name = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `file; filename=\"${name}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file) => Object.assign({headers: headers(file)}, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}