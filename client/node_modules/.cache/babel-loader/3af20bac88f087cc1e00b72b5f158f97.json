{"ast":null,"code":"'use strict';\n\nconst Qs = require('qs');\nconst qsDefaultEncoder = require('qs/lib/utils').encode;\nconst isNode = require('detect-node');\nconst ndjson = require('ndjson');\nconst pump = require('pump');\nconst once = require('once');\nconst streamToValue = require('./stream-to-value');\nconst streamToJsonValue = require('./stream-to-json-value');\nconst request = require('./request');\nconst log = require('debug')('ipfs-api:request');\n\n// -- Internal\n\nfunction parseError(res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`);\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err);\n    }\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n    cb(error);\n  });\n}\nfunction onRes(buffer, cb) {\n  return res => {\n    const stream = Boolean(res.headers['x-stream-output']);\n    const chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    const isJson = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res);\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error'];\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    }\n\n    // Return a value\n    return streamToValue(res, cb);\n  };\n}\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r;\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r;\n  }\n  options.qs['stream-channels'] = true;\n  if (options.stream) {\n    options.buffer = false;\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks;\n  const method = 'POST';\n  const headers = Object.assign({}, config.headers);\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`;\n  }\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = '';\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n            uriEncoded += String.fromCharCode(byte);\n          } else {\n            const hex = byte.toString(16);\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex;\n            uriEncoded += `%${padded}`;\n          }\n        }\n        return uriEncoded;\n      }\n      return qsDefaultEncoder(data);\n    }\n  });\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  };\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback));\n  req.on('error', err => {\n    callback(err);\n  });\n  if (!options.stream) {\n    req.end();\n  }\n  return req;\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = config => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n    return requestAPI(config, options, callback);\n  };\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n      transform(res, callback);\n    });\n  };\n  return send;\n};","map":{"version":3,"names":["Qs","require","qsDefaultEncoder","encode","isNode","ndjson","pump","once","streamToValue","streamToJsonValue","request","log","parseError","res","cb","error","Error","statusCode","err","payload","code","Code","message","Message","toString","type","Type","onRes","buffer","stream","Boolean","headers","chunkedObjects","isJson","indexOf","req","method","getHeaders","host","path","statusMessage","url","outputStream","parse","on","trailers","JSON","e","emit","requestAPI","config","options","callback","qs","Array","isArray","join","args","arg","progress","r","recursive","followSymlinks","Object","assign","multipart","multipartBoundary","stringify","arrayFormat","encoder","data","Buffer","isBuffer","uriEncoded","byte","String","fromCharCode","hex","padded","length","reqOptions","hostname","port","protocol","end","exports","module","send","andTransform","transform"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipfs-api/src/utils/send-request.js"],"sourcesContent":["'use strict'\n\nconst Qs = require('qs')\nconst qsDefaultEncoder = require('qs/lib/utils').encode\nconst isNode = require('detect-node')\nconst ndjson = require('ndjson')\nconst pump = require('pump')\nconst once = require('once')\nconst streamToValue = require('./stream-to-value')\nconst streamToJsonValue = require('./stream-to-json-value')\nconst request = require('./request')\nconst log = require('debug')('ipfs-api:request')\n\n// -- Internal\n\nfunction parseError (res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`)\n\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err)\n    }\n\n    if (payload) {\n      error.code = payload.Code\n      error.message = payload.Message || payload.toString()\n      error.type = payload.Type\n    }\n    cb(error)\n  })\n}\n\nfunction onRes (buffer, cb) {\n  return (res) => {\n    const stream = Boolean(res.headers['x-stream-output'])\n    const chunkedObjects = Boolean(res.headers['x-chunked-output'])\n    const isJson = res.headers['content-type'] &&\n                   res.headers['content-type'].indexOf('application/json') === 0\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage)\n    } else {\n      log(res.url, res.statusCode, res.statusMessage)\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb)\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res)\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse()\n      pump(res, outputStream)\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error']\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err)\n          } catch (e) {\n            err = { Message: err }\n          }\n          outputStream.emit('error', new Error(err.Message))\n        }\n      })\n      return cb(null, outputStream)\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb)\n    }\n\n    // Return a value\n    return streamToValue(res, cb)\n  }\n}\n\nfunction requestAPI (config, options, callback) {\n  callback = once(callback)\n  options.qs = options.qs || {}\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/')\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args]\n  }\n  if (options.args) {\n    options.qs.arg = options.args\n  }\n  if (options.progress) {\n    options.qs.progress = true\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r\n  }\n\n  options.qs['stream-channels'] = true\n\n  if (options.stream) {\n    options.buffer = false\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks\n\n  const method = 'POST'\n  const headers = Object.assign({}, config.headers)\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent']\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'))\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = ''\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (\n            (byte >= 0x41 && byte <= 0x5A) ||\n            (byte >= 0x61 && byte <= 0x7A) ||\n            (byte >= 0x30 && byte <= 0x39) ||\n            (byte === 0x2D) ||\n            (byte === 0x2E) ||\n            (byte === 0x5F) ||\n            (byte === 0x7E)\n          ) {\n            uriEncoded += String.fromCharCode(byte)\n          } else {\n            const hex = byte.toString(16)\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex\n            uriEncoded += `%${padded}`\n          }\n        }\n        return uriEncoded\n      }\n      return qsDefaultEncoder(data)\n    }\n  })\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  }\n\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback))\n\n  req.on('error', (err) => {\n    callback(err)\n  })\n\n  if (!options.stream) {\n    req.end()\n  }\n\n  return req\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = (config) => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'))\n    }\n\n    return requestAPI(config, options, callback)\n  }\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      transform(res, callback)\n    })\n  }\n\n  return send\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}