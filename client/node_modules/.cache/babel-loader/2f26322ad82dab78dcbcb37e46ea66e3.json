{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\nconst isNode = require('detect-node');\nconst isSource = require('is-pull-stream').isSource;\nconst toStream = require('pull-stream-to-stream');\nconst PADDING = '--';\nconst NEW_LINE = '\\r\\n';\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\nclass Multipart extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    }));\n    this._boundary = this._generateBoundary();\n    this._files = [];\n    this._draining = false;\n  }\n  _flush() {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n    this.push(null);\n  }\n  _generateBoundary() {\n    var boundary = '--------------------------';\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n    return boundary;\n  }\n  _transform(file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file);\n      return callback(); // early\n    }\n    // not a buffer, must be a file\n    this._files.push(file);\n    this._maybeDrain(callback);\n  }\n  _maybeDrain(callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true;\n        const file = this._files.shift();\n        this._pushFile(file, err => {\n          this._draining = false;\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this._maybeDrain(callback);\n          }\n        });\n      } else {\n        this.emit('drained all files');\n        callback();\n      }\n    } else {\n      this.once('drained all files', callback);\n    }\n  }\n  _pushFile(file, callback) {\n    const leading = this._leading(file.headers || {});\n    this.push(leading);\n    let content = file.content || Buffer.alloc(0);\n    if (Buffer.isBuffer(content)) {\n      this.push(content);\n      this.push(NEW_LINE_BUFFER);\n      return callback(); // early\n    }\n\n    if (isSource(content)) {\n      content = toStream.source(content);\n    }\n\n    // From now on we assume content is a stream\n\n    content.once('error', this.emit.bind(this, 'error'));\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER);\n      callback();\n\n      // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    });\n\n    content.on('data', data => {\n      const drained = this.push(data);\n      // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n      if (!drained && isNode) {\n        content.pause();\n        this.once('drain', () => content.resume());\n      }\n    });\n  }\n  _leading(headers) {\n    var leading = [PADDING + this._boundary];\n    Object.keys(headers).forEach(header => {\n      leading.push(header + ': ' + headers[header]);\n    });\n    leading.push('');\n    leading.push('');\n    const leadingStr = leading.join(NEW_LINE);\n    return Buffer.from(leadingStr);\n  }\n}\nmodule.exports = Multipart;","map":{"version":3,"names":["Transform","require","isNode","isSource","toStream","PADDING","NEW_LINE","NEW_LINE_BUFFER","Buffer","from","Multipart","constructor","options","Object","assign","objectMode","highWaterMark","_boundary","_generateBoundary","_files","_draining","_flush","push","boundary","i","Math","floor","random","toString","_transform","file","encoding","callback","isBuffer","_maybeDrain","length","shift","_pushFile","err","emit","once","leading","_leading","headers","content","alloc","source","bind","on","data","drained","pause","resume","keys","forEach","header","leadingStr","join","module","exports"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipfs-api/src/utils/multipart.js"],"sourcesContent":["'use strict'\n\nconst Transform = require('stream').Transform\nconst isNode = require('detect-node')\nconst isSource = require('is-pull-stream').isSource\nconst toStream = require('pull-stream-to-stream')\n\nconst PADDING = '--'\nconst NEW_LINE = '\\r\\n'\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE)\n\nclass Multipart extends Transform {\n  constructor (options) {\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 1 }))\n\n    this._boundary = this._generateBoundary()\n    this._files = []\n    this._draining = false\n  }\n\n  _flush () {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE))\n    this.push(null)\n  }\n\n  _generateBoundary () {\n    var boundary = '--------------------------'\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16)\n    }\n\n    return boundary\n  }\n\n  _transform (file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file)\n      return callback() // early\n    }\n    // not a buffer, must be a file\n    this._files.push(file)\n    this._maybeDrain(callback)\n  }\n\n  _maybeDrain (callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true\n        const file = this._files.shift()\n        this._pushFile(file, (err) => {\n          this._draining = false\n          if (err) {\n            this.emit('error', err)\n          } else {\n            this._maybeDrain(callback)\n          }\n        })\n      } else {\n        this.emit('drained all files')\n        callback()\n      }\n    } else {\n      this.once('drained all files', callback)\n    }\n  }\n\n  _pushFile (file, callback) {\n    const leading = this._leading(file.headers || {})\n\n    this.push(leading)\n\n    let content = file.content || Buffer.alloc(0)\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content)\n      this.push(NEW_LINE_BUFFER)\n      return callback() // early\n    }\n\n    if (isSource(content)) {\n      content = toStream.source(content)\n    }\n\n    // From now on we assume content is a stream\n\n    content.once('error', this.emit.bind(this, 'error'))\n\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER)\n      callback()\n\n      // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    })\n\n    content.on('data', (data) => {\n      const drained = this.push(data)\n      // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n      if (!drained && isNode) {\n        content.pause()\n        this.once('drain', () => content.resume())\n      }\n    })\n  }\n\n  _leading (headers) {\n    var leading = [PADDING + this._boundary]\n\n    Object.keys(headers).forEach((header) => {\n      leading.push(header + ': ' + headers[header])\n    })\n\n    leading.push('')\n    leading.push('')\n\n    const leadingStr = leading.join(NEW_LINE)\n\n    return Buffer.from(leadingStr)\n  }\n}\n\nmodule.exports = Multipart\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}