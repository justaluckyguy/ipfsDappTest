{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\nconst protons = require('protons');\nconst proto = protons(require('./dag.proto.js'));\nconst resolver = require('./resolver');\nconst DAGLink = require('./dag-link');\nconst DAGNode = require('./dag-node');\nconst multihashing = require('multihashing-async');\nconst waterfall = require('async/waterfall');\nexports = module.exports;\n\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\nfunction cid(dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  let version = options.version;\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1;\n  }\n  waterfall([cb => serialize(dagNode, cb), (serialized, cb) => multihashing(serialized, hashAlg, cb), (mh, cb) => cb(null, new CID(version, resolver.multicodec, mh))], callback);\n}\nfunction serialize(node, callback) {\n  let serialized;\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && node.links) {\n    node.links = node.links.map(link => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf(node));\n  } catch (err) {\n    return callback(err);\n  }\n  callback(null, serialized);\n}\nfunction deserialize(data, callback) {\n  const pbn = proto.PBNode.decode(data);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const buf = pbn.Data == null ? Buffer.alloc(0) : Buffer.from(pbn.Data);\n  DAGNode.create(buf, links, callback);\n}\nfunction toProtoBuf(node) {\n  const pbn = {};\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map(link => {\n      return {\n        Hash: link.multihash,\n        Name: link.name,\n        Tsize: link.size\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n  return pbn;\n}\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"names":["CID","require","protons","proto","resolver","DAGLink","DAGNode","multihashing","waterfall","exports","module","cid","dagNode","options","callback","hashAlg","defaultHashAlg","version","cb","serialize","serialized","mh","multicodec","node","isDAGNode","links","map","link","isDAGLink","util","createDagLinkFromB58EncodedHash","PBNode","encode","toProtoBuf","err","deserialize","data","pbn","decode","Links","Name","Tsize","Hash","buf","Data","Buffer","alloc","from","create","length","multihash","name","size"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipld-dag-pb/src/util.js"],"sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst resolver = require('./resolver')\nconst DAGLink = require('./dag-link')\nconst DAGNode = require('./dag-node')\nconst multihashing = require('multihashing-async')\nconst waterfall = require('async/waterfall')\n\nexports = module.exports\n\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\nfunction cid (dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg\n  let version = options.version\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1\n  }\n  waterfall([\n    (cb) => serialize(dagNode, cb),\n    (serialized, cb) => multihashing(serialized, hashAlg, cb),\n    (mh, cb) => cb(null, new CID(version, resolver.multicodec, mh))\n  ], callback)\n}\n\nfunction serialize (node, callback) {\n  let serialized\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && node.links) {\n    node.links = node.links.map((link) => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf(node))\n  } catch (err) {\n    return callback(err)\n  }\n\n  callback(null, serialized)\n}\n\nfunction deserialize (data, callback) {\n  const pbn = proto.PBNode.decode(data)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const buf = pbn.Data == null ? Buffer.alloc(0) : Buffer.from(pbn.Data)\n\n  DAGNode.create(buf, links, callback)\n}\n\nfunction toProtoBuf (node) {\n  const pbn = {}\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map((link) => {\n      return {\n        Hash: link.multihash,\n        Name: link.name,\n        Tsize: link.size\n      }\n    })\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}