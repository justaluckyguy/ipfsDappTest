{"ast":null,"code":"'use strict';\n\nconst cbor = require('borc');\nconst multihashing = require('multihashing-async');\nconst CID = require('cids');\nconst isCircular = require('is-circular');\nconst resolver = require('./resolver');\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42;\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'),\n  // thanks jdag\n  cid]));\n}\nconst decoder = new cbor.Decoder({\n  tags: {\n    [CID_CBOR_TAG]: val => {\n      // remove that 0\n      val = val.slice(1);\n      return new CID(val);\n    }\n  }\n});\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n  function transform(obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj;\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n    const keys = Object.keys(obj);\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n\n      return tagCID(obj['/']);\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n  return transform(dagNode);\n}\nexports = module.exports;\nexports.serialize = (dagNode, callback) => {\n  let serialized;\n  try {\n    const dagNodeTagged = replaceCIDbyTAG(dagNode);\n    serialized = cbor.encode(dagNodeTagged);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n  setImmediate(() => callback(null, serialized));\n};\nexports.deserialize = (data, callback) => {\n  let deserialized;\n  try {\n    deserialized = decoder.decodeFirst(data);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n  setImmediate(() => callback(null, deserialized));\n};\n\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {number} [options.hashLen] - Optionally trim the digest to this length\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\nexports.cid = (dagNode, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  const hashLen = options.hashLen;\n  const version = typeof options.version === 'undefined' ? 1 : options.version;\n  exports.serialize(dagNode, (err, serialized) => {\n    if (err) return callback(err);\n    multihashing(serialized, hashAlg, hashLen, (err, mh) => {\n      if (err) return callback(err);\n      callback(null, new CID(version, resolver.multicodec, mh));\n    });\n  });\n};","map":{"version":3,"names":["cbor","require","multihashing","CID","isCircular","resolver","CID_CBOR_TAG","tagCID","cid","buffer","isCID","Tagged","Buffer","concat","from","decoder","Decoder","tags","val","slice","replaceCIDbyTAG","dagNode","circular","e","Error","transform","obj","isBuffer","Array","isArray","map","keys","Object","length","out","forEach","key","exports","module","serialize","callback","serialized","dagNodeTagged","encode","err","setImmediate","deserialize","data","deserialized","decodeFirst","options","hashAlg","defaultHashAlg","hashLen","version","mh","multicodec"],"sources":["/home/isaak/Workspace/ipfsDapp/client/node_modules/ipld-dag-cbor/src/util.js"],"sourcesContent":["'use strict'\n\nconst cbor = require('borc')\nconst multihashing = require('multihashing-async')\nconst CID = require('cids')\nconst isCircular = require('is-circular')\n\nconst resolver = require('./resolver')\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\nfunction tagCID (cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([\n    Buffer.from('00', 'hex'), // thanks jdag\n    cid\n  ]))\n}\n\nconst decoder = new cbor.Decoder({\n  tags: {\n    [CID_CBOR_TAG]: (val) => {\n      // remove that 0\n      val = val.slice(1)\n      return new CID(val)\n    }\n  }\n})\n\nfunction replaceCIDbyTAG (dagNode) {\n  let circular\n  try {\n    circular = isCircular(dagNode)\n  } catch (e) {\n    circular = false\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references')\n  }\n\n  function transform (obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform)\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj)\n    }\n\n    const keys = Object.keys(obj)\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n\n      return tagCID(obj['/'])\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {}\n      keys.forEach((key) => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key])\n        } else {\n          out[key] = obj[key]\n        }\n      })\n      return out\n    } else {\n      return obj\n    }\n  }\n\n  return transform(dagNode)\n}\n\nexports = module.exports\n\nexports.serialize = (dagNode, callback) => {\n  let serialized\n\n  try {\n    const dagNodeTagged = replaceCIDbyTAG(dagNode)\n    serialized = cbor.encode(dagNodeTagged)\n  } catch (err) {\n    return setImmediate(() => callback(err))\n  }\n  setImmediate(() => callback(null, serialized))\n}\n\nexports.deserialize = (data, callback) => {\n  let deserialized\n\n  try {\n    deserialized = decoder.decodeFirst(data)\n  } catch (err) {\n    return setImmediate(() => callback(err))\n  }\n\n  setImmediate(() => callback(null, deserialized))\n}\n\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {number} [options.hashLen] - Optionally trim the digest to this length\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\nexports.cid = (dagNode, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg\n  const hashLen = options.hashLen\n  const version = typeof options.version === 'undefined' ? 1 : options.version\n\n  exports.serialize(dagNode, (err, serialized) => {\n    if (err) return callback(err)\n    multihashing(serialized, hashAlg, hashLen, (err, mh) => {\n      if (err) return callback(err)\n      callback(null, new CID(version, resolver.multicodec, mh))\n    })\n  })\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,YAAY,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAClD,MAAME,GAAG,GAAGF,OAAO,CAAC,MAAM,CAAC;AAC3B,MAAMG,UAAU,GAAGH,OAAO,CAAC,aAAa,CAAC;AAEzC,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,YAAY,CAAC;;AAEtC;AACA,MAAMK,YAAY,GAAG,EAAE;AAEvB,SAASC,MAAM,CAAEC,GAAG,EAAE;EACpB,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC3BA,GAAG,GAAG,IAAIL,GAAG,CAACK,GAAG,CAAC,CAACC,MAAM;EAC3B,CAAC,MAAM,IAAIN,GAAG,CAACO,KAAK,CAACF,GAAG,CAAC,EAAE;IACzBA,GAAG,GAAGA,GAAG,CAACC,MAAM;EAClB;EAEA,OAAO,IAAIT,IAAI,CAACW,MAAM,CAACL,YAAY,EAAEM,MAAM,CAACC,MAAM,CAAC,CACjDD,MAAM,CAACE,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;EAAE;EAC1BN,GAAG,CACJ,CAAC,CAAC;AACL;AAEA,MAAMO,OAAO,GAAG,IAAIf,IAAI,CAACgB,OAAO,CAAC;EAC/BC,IAAI,EAAE;IACJ,CAACX,YAAY,GAAIY,GAAG,IAAK;MACvB;MACAA,GAAG,GAAGA,GAAG,CAACC,KAAK,CAAC,CAAC,CAAC;MAClB,OAAO,IAAIhB,GAAG,CAACe,GAAG,CAAC;IACrB;EACF;AACF,CAAC,CAAC;AAEF,SAASE,eAAe,CAAEC,OAAO,EAAE;EACjC,IAAIC,QAAQ;EACZ,IAAI;IACFA,QAAQ,GAAGlB,UAAU,CAACiB,OAAO,CAAC;EAChC,CAAC,CAAC,OAAOE,CAAC,EAAE;IACVD,QAAQ,GAAG,KAAK;EAClB;EACA,IAAIA,QAAQ,EAAE;IACZ,MAAM,IAAIE,KAAK,CAAC,2CAA2C,CAAC;EAC9D;EAEA,SAASC,SAAS,CAAEC,GAAG,EAAE;IACvB,IAAI,CAACA,GAAG,IAAId,MAAM,CAACe,QAAQ,CAACD,GAAG,CAAC,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3D,OAAOA,GAAG;IACZ;IAEA,IAAIE,KAAK,CAACC,OAAO,CAACH,GAAG,CAAC,EAAE;MACtB,OAAOA,GAAG,CAACI,GAAG,CAACL,SAAS,CAAC;IAC3B;IAEA,IAAItB,GAAG,CAACO,KAAK,CAACgB,GAAG,CAAC,EAAE;MAClB,OAAOnB,MAAM,CAACmB,GAAG,CAAC;IACpB;IAEA,MAAMK,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACL,GAAG,CAAC;IAE7B,IAAIK,IAAI,CAACE,MAAM,KAAK,CAAC,IAAIF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACxC;MACA;MACA;MACA;;MAEA,OAAOxB,MAAM,CAACmB,GAAG,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC,MAAM,IAAIK,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;MAC1B;MACA,MAAMC,GAAG,GAAG,CAAC,CAAC;MACdH,IAAI,CAACI,OAAO,CAAEC,GAAG,IAAK;QACpB,IAAI,OAAOV,GAAG,CAACU,GAAG,CAAC,KAAK,QAAQ,EAAE;UAChCF,GAAG,CAACE,GAAG,CAAC,GAAGX,SAAS,CAACC,GAAG,CAACU,GAAG,CAAC,CAAC;QAChC,CAAC,MAAM;UACLF,GAAG,CAACE,GAAG,CAAC,GAAGV,GAAG,CAACU,GAAG,CAAC;QACrB;MACF,CAAC,CAAC;MACF,OAAOF,GAAG;IACZ,CAAC,MAAM;MACL,OAAOR,GAAG;IACZ;EACF;EAEA,OAAOD,SAAS,CAACJ,OAAO,CAAC;AAC3B;AAEAgB,OAAO,GAAGC,MAAM,CAACD,OAAO;AAExBA,OAAO,CAACE,SAAS,GAAG,CAAClB,OAAO,EAAEmB,QAAQ,KAAK;EACzC,IAAIC,UAAU;EAEd,IAAI;IACF,MAAMC,aAAa,GAAGtB,eAAe,CAACC,OAAO,CAAC;IAC9CoB,UAAU,GAAGzC,IAAI,CAAC2C,MAAM,CAACD,aAAa,CAAC;EACzC,CAAC,CAAC,OAAOE,GAAG,EAAE;IACZ,OAAOC,YAAY,CAAC,MAAML,QAAQ,CAACI,GAAG,CAAC,CAAC;EAC1C;EACAC,YAAY,CAAC,MAAML,QAAQ,CAAC,IAAI,EAAEC,UAAU,CAAC,CAAC;AAChD,CAAC;AAEDJ,OAAO,CAACS,WAAW,GAAG,CAACC,IAAI,EAAEP,QAAQ,KAAK;EACxC,IAAIQ,YAAY;EAEhB,IAAI;IACFA,YAAY,GAAGjC,OAAO,CAACkC,WAAW,CAACF,IAAI,CAAC;EAC1C,CAAC,CAAC,OAAOH,GAAG,EAAE;IACZ,OAAOC,YAAY,CAAC,MAAML,QAAQ,CAACI,GAAG,CAAC,CAAC;EAC1C;EAEAC,YAAY,CAAC,MAAML,QAAQ,CAAC,IAAI,EAAEQ,YAAY,CAAC,CAAC;AAClD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,OAAO,CAAC7B,GAAG,GAAG,CAACa,OAAO,EAAE6B,OAAO,EAAEV,QAAQ,KAAK;EAC5C,IAAI,OAAOU,OAAO,KAAK,UAAU,EAAE;IACjCV,QAAQ,GAAGU,OAAO;IAClBA,OAAO,GAAG,CAAC,CAAC;EACd;EACAA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,MAAMC,OAAO,GAAGD,OAAO,CAACC,OAAO,IAAI9C,QAAQ,CAAC+C,cAAc;EAC1D,MAAMC,OAAO,GAAGH,OAAO,CAACG,OAAO;EAC/B,MAAMC,OAAO,GAAG,OAAOJ,OAAO,CAACI,OAAO,KAAK,WAAW,GAAG,CAAC,GAAGJ,OAAO,CAACI,OAAO;EAE5EjB,OAAO,CAACE,SAAS,CAAClB,OAAO,EAAE,CAACuB,GAAG,EAAEH,UAAU,KAAK;IAC9C,IAAIG,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;IAC7B1C,YAAY,CAACuC,UAAU,EAAEU,OAAO,EAAEE,OAAO,EAAE,CAACT,GAAG,EAAEW,EAAE,KAAK;MACtD,IAAIX,GAAG,EAAE,OAAOJ,QAAQ,CAACI,GAAG,CAAC;MAC7BJ,QAAQ,CAAC,IAAI,EAAE,IAAIrC,GAAG,CAACmD,OAAO,EAAEjD,QAAQ,CAACmD,UAAU,EAAED,EAAE,CAAC,CAAC;IAC3D,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"script"}